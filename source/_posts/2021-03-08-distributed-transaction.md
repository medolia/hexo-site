---
title: 一些分布式事务的思考
date: 2021/3/08 01:45:50
categories: 编程
tags:
  - 分布式
excerpt: 在微服务环境下分布式事务的实现方案
---

## TCC 事务/一致性事务

如果对一致性要求是强一致性，那么就需要各微服务之前同步调用，即实现事务的原子性，“All or None”。

![任意一个服务出错时，所有服务都需要回滚](https://medoliablog.oss-cn-hangzhou.aliyuncs.com/2021/03/08/16151384960966.jpg)


### Try 阶段

各服务锁定事物所需要的资源，例如库存服务，假设当前共有 100 个库存，而事务需要 2 个库存，那么可以单独在库中定义一个字段记录被冻结的库存量，即更新库存为 98 冻结库存为 2。
而订单服务中，订单状态需要设置为 UPDATING（待更新）。

### Confirm 阶段

若 Try 阶段所有服务都成功操作了，那么这一阶段主要执行各服务的收尾逻辑（可通过开源的 TCC 事务框架实现）。例如，库存服务清零冻结库存，订单状态更新为 PAID（已支付）。

### Cancel 阶段

上述两个阶段任何一个环境出错，都会被事务框架感知到并执行所有服务的 Cancel 逻辑。例如，库存服务把库存加回来，订单状态修改为 CANCELED（已取消）。

### 小结

TCC 事务用于各服务直接同步调用（比如 Spring Cloud Feign），而且需要强一致性的情况（All or None）。比如和 **钱** 有关的绝大部分场景。。。且事务框架进行对事务的各阶段进行感知十分重要。

## 最终一致性分布式事务

当服务间的调用是通过消息队列进行异步调用时，需要考虑分布式事务的最终一致性。核心主要是两点：**可靠消息服务** 和 **最终一致性**。

![](https://medoliablog.oss-cn-hangzhou.aliyuncs.com/2021/03/08/16151415900569.png)


### 上游消息投递服务

1. 发送一条消息给可靠消息服务，消息包含事务信息，可靠消息服务将这条消息存入数据库，标记为 **待确认** 。
2. 上游服务执行自己的数据库操作，若成功则找可靠消息服务确认那条消息。
3. 可靠消息服务更新消息状态为 **已发送** 并发送给 MQ，否则删除这条消息，注意更新状态和发送给 MQ 需要使用一个本地事务实现原子性。

### 下游消息接收消息

下游服务收到消息后进行数据库操作，如果成功标记信息为 **已完成** 返回给上游。

### 如何确保上游消息 100% 投递至可靠消息中心？

可靠消息服务会起一个后台定时线程负责检查 “待确认” 的消息，持续轮询上游服务确认消息状态。此外，可靠消息服务确保消息一定会到达 MQ。

### 如何确保下游 100% 接收到消息？

可靠消息服务会起一个后台定时线程负责 “已发送” 的消息，如果没有变成 “已完成” 则会再发送一次消息。由下游负责消息消费的幂等性。

### 可靠消息服务框架 RocketMQ 做到了什么？

1. 如果上游服务的数据库操作没成功，下游服务是不会收到任何通知；
2. 如果上游服务的数据库操作成功了，可靠消息服务死活都会确保将一个调用消息投递给下游服务，而且一定会确保下游服务务必成功处理这条消息；

## 巨人的肩膀

[石杉的架构笔记 - 分布式事务](https://shishan100.gitee.io/docs/#/./docs/distributed-system/distributed-transaction)



